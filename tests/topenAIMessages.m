classdef topenAIMessages < matlab.unittest.TestCase
% Tests for openAIMessages

%   Copyright 2023 The MathWorks, Inc.

    properties(TestParameter)
        InvalidInputsUserPrompt = iGetInvalidInputsUserPrompt;
        InvalidInputsFunctionPrompt = iGetInvalidFunctionPrompt;
        InvalidInputsSystemPrompt = iGetInvalidInputsSystemPrompt;
        InvalidInputsResponseMessage = iGetInvalidInputsResponseMessage;
        InvalidRemoveMessage = iGetInvalidRemoveMessage;     
        ValidTextInput = {"This is okay"; 'this is ok'};
    end

    methods(Test)
        function constructorStartsWithEmptyMessages(testCase)
            msgs = openAIMessages;
            testCase.verifyTrue(isempty(msgs.Messages));
        end

        function differentInputTextAccepted(testCase, ValidTextInput)
            msgs = openAIMessages;
            testCase.verifyWarningFree(@()addSystemMessage(msgs, ValidTextInput, ValidTextInput));
            testCase.verifyWarningFree(@()addSystemMessage(msgs, ValidTextInput, ValidTextInput));
            testCase.verifyWarningFree(@()addUserMessage(msgs, ValidTextInput));
            testCase.verifyWarningFree(@()addFunctionMessage(msgs, ValidTextInput, ValidTextInput));
        end
        

        function systemMessageIsAdded(testCase)
            prompt = "Here is a system prompt";
            name = "example";
            msgs = openAIMessages;
            systemPrompt = struct("role", "system", "name", name, "content", prompt);
            msgs = addSystemMessage(msgs, name, prompt);
            testCase.verifyEqual(msgs.Messages{1}, systemPrompt);
        end

        function userMessageIsAdded(testCase)
            prompt = "Here is a user prompt";
            msgs = openAIMessages;
            userPrompt = struct("role", "user", "content", prompt);
            msgs = addUserMessage(msgs, prompt);
            testCase.verifyEqual(msgs.Messages{1}, userPrompt);
        end

        function functionMessageIsAdded(testCase)
            prompt = "20";
            name = "sin";
            msgs = openAIMessages;
            systemPrompt = struct("role", "function", "name", name, "content", prompt);
            msgs = addFunctionMessage(msgs, name, prompt);
            testCase.verifyEqual(msgs.Messages{1}, systemPrompt);
        end

        function assistantMessageIsAdded(testCase)
            prompt = "Here is an assistant prompt";
            msgs = openAIMessages;
            assistantPrompt = struct("role", "assistant", "content", prompt);
            msgs = addResponseMessage(msgs, assistantPrompt);
            testCase.verifyEqual(msgs.Messages{1}, assistantPrompt);
        end

        function assistantFunctionCallMessageIsAdded(testCase)
            functionName = "functionName";
            msgs = openAIMessages;
            args = "{""arg1"": 1, ""arg2"": 2, ""arg3"": ""3""}";
            funCall = struct("name", functionName, "arguments", args);
            functionCallPrompt = struct("role", "assistant", "content", "", "function_call", funCall);
            msgs = addResponseMessage(msgs, functionCallPrompt);
            testCase.verifyEqual(msgs.Messages{1}, functionCallPrompt);
        end

        function assistantFunctionCallMessageWithoutArgsIsAdded(testCase)
            functionName = "functionName";
            msgs = openAIMessages;
            funCall = struct("name", functionName, "arguments", "{}");
            functionCallPrompt = struct("role", "assistant", "content", "", "function_call", funCall);
            msgs = addResponseMessage(msgs, functionCallPrompt);
            testCase.verifyEqual(msgs.Messages{1}, functionCallPrompt);
        end

        function messageGetsRemoved(testCase)
            msgs = openAIMessages;
            idx = 2;
            
            msgs = addSystemMessage(msgs, "name", "content");
            msgs = addUserMessage(msgs, "content"); 
            msgs = addFunctionMessage(msgs, "name", "content");
            sizeMsgs = length(msgs.Messages);
            % Message exists before removal
            msgToBeRemoved = msgs.Messages{idx};
            testCase.verifyTrue(any(cellfun(@(c) isequal(c,  msgToBeRemoved), msgs.Messages)));
            
            msgs = removeMessage(msgs, idx);
            testCase.verifyFalse(any(cellfun(@(c) isequal(c,  msgToBeRemoved), msgs.Messages)));
            testCase.verifyEqual(length(msgs.Messages), sizeMsgs-1);
        end

        function removalIdxCantBeLargerThanNumElements(testCase)
            msgs = openAIMessages;
            
            msgs = addSystemMessage(msgs, "name", "content");
            msgs = addUserMessage(msgs, "content"); 
            msgs = addFunctionMessage(msgs, "name", "content");
            sizeMsgs = length(msgs.Messages);

            testCase.verifyError(@()removeMessage(msgs, sizeMsgs+1), "llms:mustBeValidIndex");
        end

        function invalidInputsSystemPrompt(testCase, InvalidInputsSystemPrompt)
            msgs = openAIMessages;
            testCase.verifyError(@()addSystemMessage(msgs,InvalidInputsSystemPrompt.Input{:}), InvalidInputsSystemPrompt.Error);
        end

        function invalidInputsUserPrompt(testCase, InvalidInputsUserPrompt)
            msgs = openAIMessages;
            testCase.verifyError(@()addUserMessage(msgs,InvalidInputsUserPrompt.Input{:}), InvalidInputsUserPrompt.Error);
        end

        function invalidInputsFunctionPrompt(testCase, InvalidInputsFunctionPrompt)
            msgs = openAIMessages;
            testCase.verifyError(@()addFunctionMessage(msgs,InvalidInputsFunctionPrompt.Input{:}), InvalidInputsFunctionPrompt.Error);
        end

        function invalidInputsRemove(testCase, InvalidRemoveMessage)
            msgs = openAIMessages;
            testCase.verifyError(@()removeMessage(msgs,InvalidRemoveMessage.Input{:}), InvalidRemoveMessage.Error);
        end

        function invalidInputsResponsePrompt(testCase, InvalidInputsResponseMessage)
            msgs = openAIMessages;
            testCase.verifyError(@()addResponseMessage(msgs,InvalidInputsResponseMessage.Input{:}), InvalidInputsResponseMessage.Error);
        end
    end  
end

function invalidInputsSystemPrompt = iGetInvalidInputsSystemPrompt
    invalidInputsSystemPrompt = struct( ...
        "NonStringInputName", ...
            struct("Input", {{123, "content"}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "NonStringInputContent", ...
            struct("Input", {{"name", 123}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "EmptytName", ...
            struct("Input", {{"", "content"}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "EmptytContent", ...
            struct("Input", {{"name", ""}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "NonScalarInputName", ...
            struct("Input", {{["name1" "name2"], "content"}}, ...
            "Error", "MATLAB:validators:mustBeTextScalar"),...
        ...
        "NonScalarInputContent", ...
            struct("Input", {{"name", ["content1", "content2"]}}, ...
            "Error", "MATLAB:validators:mustBeTextScalar"));
end

function invalidInputsUserPrompt = iGetInvalidInputsUserPrompt
    invalidInputsUserPrompt = struct( ...
        "NonStringInput", ...
            struct("Input", {{123}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "NonScalarInput", ...
            struct("Input", {{["prompt1" "prompt2"]}}, ...
            "Error", "MATLAB:validators:mustBeTextScalar"), ...
            ...
        "EmptyInput", ...
            struct("Input", {{""}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"));
end

function invalidFunctionPrompt = iGetInvalidFunctionPrompt
    invalidFunctionPrompt = struct( ...
        "NonStringInputName", ...
            struct("Input", {{123, "content"}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "NonStringInputContent", ...
            struct("Input", {{"name", 123}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "EmptytName", ...
            struct("Input", {{"", "content"}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "EmptytContent", ...
            struct("Input", {{"name", ""}}, ...
            "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
        ...
        "NonScalarInputName", ...
            struct("Input", {{["name1" "name2"], "content"}}, ...
            "Error", "MATLAB:validators:mustBeTextScalar"),...
        ...
        "NonScalarInputContent", ...
            struct("Input", {{"name", ["content1", "content2"]}}, ...
            "Error", "MATLAB:validators:mustBeTextScalar"));
end

function invalidRemoveMessage = iGetInvalidRemoveMessage
    invalidRemoveMessage = struct( ...
        "NonInteger", ...
            struct("Input", {{0.5}}, ...
            "Error", "MATLAB:validators:mustBeInteger"), ...
        ...
        "NonPositive", ...
            struct("Input", {{0}}, ...
            "Error", "MATLAB:validators:mustBePositive"), ...
        ...
        "NonScalarInput", ...
            struct("Input", {{[1 2]}}, ...
            "Error", "MATLAB:validation:IncompatibleSize"));
end

function invalidInputsResponseMessage = iGetInvalidInputsResponseMessage
    invalidInputsResponseMessage = struct( ...
        "NonStructInput", ... 
            struct("Input", {{123}},...
            "Error", "MATLAB:validation:UnableToConvert"),...
        ...
        "NonExistentRole", ... 
            struct("Input", {{struct("role", "123", "content", "123")}},...
            "Error", "llms:mustBeAssistantCall"),...
        ...
        "NonExistentContent", ... 
            struct("Input", {{struct("role", "assistant")}},...
            "Error", "llms:mustBeAssistantCall"),...
        ...
        "EmptyContent", ... 
            struct("Input", {{struct("role", "assistant", "content", "")}},...
            "Error", "llms:mustBeAssistantWithContent"),...
        ...
        "NonScalarContent", ... 
            struct("Input", {{struct("role", "assistant", "content", ["a", "b"])}},...
            "Error", "llms:mustBeAssistantWithContent"),...
        ...
        "NoArgumentsWithFunCall", ... 
            struct("Input", {{struct("role", "assistant", "content", "", ...
                "function_call", struct("name", ""))}},...
            "Error", "llms:mustBeAssistantWithNameAndArguments"),...
        ...
        "NoNameWithFunCall", ... 
            struct("Input", {{struct("role", "assistant", "content", "", ...
                "function_call", struct("arguments", ""))}},...
            "Error", "llms:mustBeAssistantWithNameAndArguments"),...
        ...
        "ZeroLenNameWithFunCall", ... 
            struct("Input", {{struct("role", "assistant", "content", "", ...
                "function_call", struct("name", "", "arguments", "args here"))}},...
            "Error", "llms:assistantMustHaveTextNameAndArguments"),...
        ...
        "ZeroLenArgumentsWithFunCall", ... 
            struct("Input", {{struct("role", "assistant", "content", "", ...
                "function_call", struct("name", "name here", "arguments", ""))}},...
            "Error", "llms:assistantMustHaveTextNameAndArguments"),...
        ...
        "NonScalarNameWithFunCall", ... 
            struct("Input", {{struct("role", "assistant", "content", "", ...
                "function_call", struct("name", ["a", "b"], "arguments", "args here"))}},...
            "Error", "llms:assistantMustHaveTextNameAndArguments"),...
        ...
        "NonScalarArgumentsWithFunCall", ... 
            struct("Input", {{struct("role", "assistant", "content", "", ...
                "function_call", struct("name", "name here", "arguments", ["a", "b"]))}},...
            "Error", "llms:assistantMustHaveTextNameAndArguments"));
end